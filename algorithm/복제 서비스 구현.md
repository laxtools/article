# 복제 서비스 구현

- 요청의 복제
- 결과의 복제

## 요청의 복제

요청을 통해 복제를 한다는 뜻이다. 노드 A에 있는 인스턴스 관리 서비스와
노드 B에 있는 인스턴스 관리 서비스에 동시에 요청을 보낸다.

처음 상태가 같고 실행하는 코드가 동일하며 동시에 상태를 변경하는 대상이
없다고 하면 결과도 같아야 한다.

이런 특성을 갖는 서비스를 확정적인(deterministic)
비공유 (non-shared) 서비스라고 하자.

이런 서비스의 경우 standby 서비스에서 응답을 막는 것만으로
복제 서비스의 구현이 가능하다.

이 부분은 아래에서 살피면서 장애 후 재시작하거나 새로운 노드에
서비스를 추가할 수 없는 한계가 있다. 따라서, 요청 기반의 복제는 폐기한다.

## 결과의 복제

결과의 복제는 결과 상태의 복제라는 뜻이다. 노드 A에서 실행한 결과를
노드 B에 전송하고 노드 B가 반영한다.

이런 상태 복제가 동작하려면 추가 프로토콜을 개발해야 한다.

따라서, 상태 복제가 이미 가능한 서비스를 두고
각 서비스가 여기에 의존하여 복제를 수행하는 방식이 적합해 보인다.

redis 클러스터나 NoSQL 클러스터를 두고 여기에 의존하는 서비스를
구현하는 방식이다. 그렇지 않을 경우 프로토콜 구현이 복잡해질 것으로 보인다.

하지만 시도해 볼 수는 있을 듯 하고 분산 시스테의 다양한 난제들을
만나고 해결하게 될 것이다.

# 복제 시스템 예시

1억명 정도의 동시 접속자를 갖는 전세계적으로 성공한 실시간 대전 전략 게임을
서비스 하기 위한 안정적인 시스템을 구현해야 한다고 가정한다.

절대 크래시가 있어서는 안 되는 인증 서비스와 장애 영향이 크지는 않지만
여전히 중요한 매칭 서비스를 복제를 포함하여 안정적으로 제공하는 방법을 살펴본다.

## 인증 서비스

서버 이동 시 인증이 필요하고 매칭 후 서버가 바뀔 수 있어
게임 플레이 시간과 매칭 시간 정도 보다 큰 시간 간격으로 요청이 발생한다.

모두 활성화된 상태로 동작하는 것이 좋고 인증 시점의 정보만 복제되면 된다.
따라서, 요청의 복제가 아닌 인증 결과의 복제가 된다.

전체 인증 서비스에 인증 후 즉시 보낸다.

인증 서비스의 특성은 NoSQl이나 redis와 같이 <key, value> 저장소 역할을
하기 때문에 위와 같이 결과인 데이터 복제로 동작한다.

인증을 적절히 분산하는 것은 랜덤하게 요청하여 균등하게 분산하거나
인증 키의 해시 값으로 비교적 균등하게 분산 시킬 수 있다.

## 매칭 서비스

매칭 서비스는 매칭 서비스 장애 시 취소 처리로 장애 대응이 가능하다.

매칭 범위를 각 서비스에 대응시키면 1억 건의 요청이라고 하더라도
몇 개의 노드면 충분할 것으로 보인다.

왜냐하면, 매칭 후 게임에 들어가면 매칭 정보는 소멸되고
동시에 매칭을 처리하는 건수는 많지 않기 때문이다.

## 인스턴스 디렉토리 서비스

관전을 위해 인스턴스 정보들이 유지될 필요가 있다. 어떤 게임들은
인스턴스가 소멸 되지 않고 진입하는 방식으로 매칭이 되는 경우도 있다.

생성과 소멸, 상태 변경을 전체 인스턴스 서비스에 전송하는 방식으로
처리할 수 있다. 처리의 분산은 인증 서비스와 동일한 방식으로 나눌 수 있다.

시간 차이를 극복하기 위해 각 엔트리에 TTL을 두고 확신을
갖는 항목에 대해서만 검색이 가능하게 하면 이슈 없이 처리 가능하다.

## 장애 복구

복제된 서비스를 구동하던 서버가 다시 시작할 경우나 새로 추가될 경우
정보가 다를 수 있다. 이를 완전히 동기화할 방법이 필요하다.
결국 요청 기반의 복제는 이 부분 때문에 잘 동작하지 않는다는 걸 알 수 있다.

## 복제 가능한 저장소 구현

분산되고 복제 가능하며 분산 쿼리가 가능한 저장소를 내장하고
메세지를 처리하는 기능을 포함하면 안정된 서비스 제공이 가능해 보인다.

인증 서비스, 인스턴스 디렉토리 서비스에 가장 잘 활용할 수 있어 보인다.
인스턴스 디렉토리 서비스는 분산 쿼리 기능을 포함해야 한다.

C++에 포함 가능한 구현을 찾는다.

## 클래스 구현

복제를 서비스에 대해 일관되게 구현하고 복제된 서비스를 사용할 수 있는
방법이 필요하다. '일관성'은 개념화를 필요로 한다.

이제 연결 대신 서비스와 통신하고 장애를 처리하는 방법이 필요하다.

### 장애의 판정

서비스에 대해 health check를 하는 주기적인 heartbeat 패킷을 둔다.
이를 묶어서 클래스화 해야 한다.

### 대략의 인터페이스

service_ref instance_dir( 'instance directory')
instance_dir.send();
