# 분산 시스템의 장애 판단

tcp로 연결된 노드 간에 장애의 종류에 대해 정리하고
각 장애 상황을 판단하는 기준과 대응 방법을 살펴본다.

여기서는 서버 노드들에 대해서만 살펴본다.
클라이언트 노드의 단선과 hand-over는 별도로 정리한다.

## 연결 기반

tcp와 같이 연결 상태를 관리하는 프로토콜이 아닌 경우는
다른 방법이 필요하다.

연결 기반은 연결이 명시적으로 종료되는 경우와
타임아웃으로 종료되는 경우로 나뉜다.

연결의 명시적인 종료는 tcp의 경우 FIN이나 RST를 수신한
경우에 해당하고 타임아웃에 의한 종료는 TCP 타임아웃 시간이
경과한 후에 확인된다.

애플리케이션 입장에서 연결 에러는 수신을 처리하는 과정이나
송신을 처리하는 과정에서 확인된다.

## 단선 효과

단선이 발생하면 단선 이전 시점의 일정 시간 동안 통신한
패킷들이 누락될 수 있다.

따라서, 모든 전송은 단선에 대한 처리가 필요하다.
이는 단선 시 처리 안 하는 경우를 포함한다. (무처리의 처리)

단선 시 처리를 위해 단선이 전파되어야 한다.

## 단선 전파

특정 노드에는 여러 가지 서비스가 있다는 걸 의미한다.

단선은 이들 서비스를 사용할 수 없다는 걸 의미하고
단선에 대해 어떻게 대응해야 할 지 각 영역별로 결정해야 한다.

따라서, 서비스나 연결 자체에 대해 '단선'의 통지를 요청하고
이를 전파 받을 수 있어야 한다. 연결 보다는 노드에서
실행 중인 '서비스'의 상태 통지 형태로 받는 것이 subscription과
posting 모두 괜찮을 것으로 보인다.

아래의 세 가지 경우가 있다.
- 서비스에 영향을 받지 않는 경우
- 서비스 복구를 대기해야 하는 경우
  - 즉시, fail over가 가능한 경우
  - 원래 서비스의 복구를 기다려야만 하는 경우
- 서비스 복구시까지 임시로 처리가 가능한 경우

1번의 형태로 구성하거나 2, 3번을 묶어서 SPOF가 없는 서비스로
백엔드 서비스를 구성하는 것이 최선이다.

왜냐하면 패킷 누락에 대한 복구 코드의 구현이 매우 복잡하고
민감하기 때문이다. 상위 애플리케이션에서 패킷 복구 코드를
넣는 것과 동일한데 그 동안 수 많은 동작이 가능하기 때문이다.

예를 들어, 아이템 루팅을 처리한다고 하면 초당 아주 많은 건수가
발생할 수 있기 때문이다.

### 단선에 견디는 프로토콜

생각보다 어렵다. 일단, 타임아웃 처리와 서비스 상태를
파악해서 처리하는 걸 같이 봐야 한다.

### SPOF 없는 시스템의 구성

Replication과 heartbeat를 통해 fail-over를 구현한다.

에를 들어, MMORPG의 월드 서버를 두 개로 나누고
사용자, 파티, 길드 정보, 인스턴스 정보를 두 개 모두에 분산해서 등록하고
standby 모드인 서비스는 응답을 하지 않도록 한다.

active / standby를 노드 별로 나누어 설정하면 서버별 CPU를
최대한 활용할 수 있다.

긴 동작을 실행하는 코드가 있는 서버의 replication은 별도의 주제이며
이 부분도 생각보다 어려울 것 같다.

# 정리

다음과 같은 구조와 구현이 필요하다.
- 서비스를 연결 기능을 포함하도록 추상화
  - 상태 체크 / 전송 / 자동 replcaition / subscription과 posting
- 서비스 단위 replication과 fail over
