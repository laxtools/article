# 비동기 처리

게임 서버를 구현할 때 분산 시스템의 성격을 갖는 노드간의 통신이나
별도의 쓰레드를 통한 처리는 비동기로 진행된다.

통보하고 결과를 받지 않아도 되는 경우와 요청하고 결과를 받는 경우가 있다.
결과를 받는 경우 원래 요청한 노드 상의 요청한 오브젝트의 쓰레드 문맥에서
실행되어야 하는 경우가 많이 있다. 특히, 싱글 쓰레드 문맥에서 실행하는 경우 중요하다.

C#의 경우 async 키워드와 task로 비동기 처리를 진행하고
C++의 경우 future / promise가 제공된다.

둘 다 실행 문맥이 쓰레드 풀이고 완료 여부를 대기하는 지점이 필요하다.

기존의 개념들을 정리한 후 게임 서버에 적합한 메세지 기반의 비동기 처리 구조를
찾아 정리한다.

## callback

channel이 메세지 배포 기능이 있는 클래스라고 할 때
channel.subscribe( message, callback )으로 응답에 대해 등록하면
message의 비동기 처리가 가능하다.

콜백 함수를 분리하지 않고 메세지 자체에 처리 기능을 추가할 수 있으며
CPS (Continuation Passing Style)처럼 응답 메세지에 요청 내용을
포함하면 요청 문맥을 파악해서 처리가 가능하다.

단선이나 특정 서비스 장애로 인한 에러 처리를 고려하지 않으면
전체 흐름은 간단하게 처리된다.

### 용례 - DB query

DB에 대한 쿼리 요청은 쓰레드 풀에서 비동기로 처리되고
결과에 대한 처리가 게임 문맥에서 처리되는 대표적인 경우다.

request와 response가 분리된 메세지로 처리될 경우
위의 콜백 설정으로 처리 가능하다.

만약 query란 클래스를 만들고 단일 클래스 내에서
요청과 응답 처리를 포함한다고 하면 요청/응답의 문맥에 따른
디스패칭이 필요하다.

하나의 방법은 요청 채널과 응답 채널을 분리하는 것이다.

    channel_request.post( query ) --> db query 실행기로 전달
    channel_response.post( query ) --> 응답 처리기로 전달

단일 채널을 사용하는 경우 query의 상태에 따라
호출 함수를 다르게 하는 방법이 있다.

위와 같이 채널에 기반해서 구현하는 방법 외에 요청은 직접 실행기를 선택하는
방법이 있다.

db_query_scheduler.post( query ); --> 직접 요청
db_response_channel.post( query ); --> 실행 후 호출

어떤 방법을 쓰든 가능할 것으로 보인다.

## future / promise

이 쪽은 구현마다 task 처리 구조가 달라 제어가 어렵다.

promise는 producer / writer이고 future는 promise의
consumer / reader이다.

future.get() 함수는 블럭킹 되므로 여러 쓰레드를 사용하는 처리 구조에서
편리하게 처리를 분리할 때 사용한다.

게임은 블럭킹 되는 호출을 사용하면 안 되므로 적합한 구조는 아니다.

# 정리

에러 처리를 제외하면 채널 분리로 문맥을 관리하고
callback으로 비동기 처리 구조를 만들 수 있다는 점을 살펴 보았다.

db 처리와 같이 비동기 처리가 문맥을 갖고 실행되는 구조를 구현할 때
참고해서 정리하면 된다.
