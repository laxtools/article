# 코딩 규약 

코딩 규약은 이름을 짓는데서 멈추지 않고 견고한 코드를 유지하고 효율적으로 개발하는 습관을 팀 전체가 몸으로 체득하는 과정을 정리한 내용입니다.  따라서, 같이 얘기해야 하고 점진적이면서 지속적으로 개선하는 노력을 멈추지 않아야 합니다. 

중요한 명명 규칙들은 이미 확립되어 있지만 새로운 컨벤션들이 추가되고 있어 이는 정정해서 지킬 수 있도록 독려하고 격려해야 합니다. 

## 중요한 규약들

- VERIFY 계열을 검사 매크로로 사용 

  - GetOwner*()에 대한 검증 

- 참조 사용이 가능하면 참조형 사용하기 

  - 모든 포인터 체크하기 
  - Action과 Attribute의 참조형 사용 

  ​



## VERIFY_* 계열을 검사 매크로로 사용 

VERIFY는 assert와 구문이 연결되어 있습니다. VERIFY_RETURN()은 조건을 요구하고 (항상 성립해야 함) 맞지 않으면 결과값을 리턴하여 함수 실행을 종결합니다. 

VERIFY_DO, VERIFY_CONTINUE, VERIFY_BREAK 함수들이 있습니다. ASSERT를 내부에서 호출하고 있어 ASSERT 로그가 남을 수 있습니다. 따라서, ASSERT를 써야 할 곳에서 VERIFY를 사용합니다. 

### GetOwner*()에 대한 검증 

XX 서버 코드와 구현 상의 여러 가지 실수들 중의 하나가 Entity가 타잎을 갖지 않도록 설계된 것입니다. 타잎은 컴파일 시간에 오류를 찾게 해줄 뿐만 아니라 실행 시간에도 해당 타잎만이 갖고 있는 특성(상태와 함수)을 직접 사용할 수 있게 해서 여러 가지 편의를 제공할 뿐만 아니라 안정성에도 중요한 역할을 합니다. 

타잎은 컴퓨터 과학 발전에서 가장 중요한 성과 중 하나이며 C++이 타잎 계산이 가능한 유일한 명령형 언어로 앞으로도 많이 쓰일 이유 중 가장 중요한 부분입니다. 

프로젝트 초반에는 위험성이 잘 드러나지 않았지만 전체 코드를 결정하게 되면서 안정성까지 위협하는 요소가 되었고 매번 타잎 체크를 해야 하는 코드가 늘어나면서 코드 복잡도도 올라가게 되었습니다. 

현재 정리되고 추가된 각 엔티티 타잎 구조를 사용할 수 있는 GetOwnerPlayer(), GetOwnerNpc() 등을 사용하여 최종 타잎으로 직접 전환하여 검증하고 사용하면 완화시킬 수 있습니다.  

```c++
void Action*::DoSomething() 
{
    VERIFY_RETURN(GetOwnerPlayer() && GetOwnerPlayer()->IsValid());    
    ...
}
```

위 코드를 모든 public Action 함수들에 다 있다고 생각하면 될 것 같습니다. 코드 중간에 여러 엔티티를 처리하는 경우에도 EntityUnit이나 EntityPlayer, EntityNpc와 같이 타겟 타잎인지 확인하는 코드가 반드시 필요합니다. 

불편하긴 하지만 참조형 Action, Attribute 사용으로 코딩을 할 때 안정성 관련 고민을 줄일 수 있어 이전 보다는 나아진 구조라 할 수 있습니다. 

## 참조형 사용 

참조형 사용은 "모든 포인터 체크하기"가 서버에서 필수적이란 점을 생각하면 당연한 선택이라 할 수 있습니다. 참조형의 실행 시간 구현은 포인터와 동일하지만 컴파일 시 의미는 일반 변수처럼 동작합니다. 참조형을 얻었다고 하면 대상 객체는 유효하다고 생각할 수 있습니다.  

참조형도 결국은 다른 오브젝트를 가리키는 용도이기 때문에 "완전히" 안전하지는 않습니다. 단지, 참조형은 nullptr로 초기화 할 수가 없습니다. 원래 참조하던 대상이 사라지면 포인터랑 동일하게 위험하지만 길게 보유하지 않는 어떤 오브젝트에 대한 참조는 상대적으로 포인터 보다 "더" 안전하다고 할 수 있습니다. 

다른 중요한 점은 작성시 포인터로 처리하지 않기 때문에 "마음"이 더 편안하게 코딩을 진행할 수 있다는 점입니다. 또 어떤 함수에 "친절하게" 참조형을 전달해주면 함수 실행 동안에 해당 참조는 안전이 보장되어 있다는 점입니다.  포인터는 그러지 않을 가능성이 참조보다 높습니다. 

```c++
// 참조형을 안전하지 않게 하려면 한번의 간접적인 파괴가 필요. 
int* i = nullptr;
int& v = *i;
```

모든 null을 갖고 있는 언어는 위험합니다. 특히, null의 의미를 false로 동시에 사용하는 코드가 있고 사용될 경우 급격하게 확산됩니다.  이런 점을 항상 참조를 리턴하게 한다면 bool 함수 하나를 더 필요하게 만들고 체크 후 사용하게 만듭니다.  XX의 코드에서는 GlobalScripts가 대표적인 예입니다. 

```c++
if ( GetSkillScript().Has( skillId ) )
{
    auto& elem = GetSkillScript().Get(skillId); 
    .... 
}
else 
{
    // 에러 처리 
}
```

Has()로 체크하고 처리하는 부분이 귀찮다 생각될 수 있지만 얻는 이득은 매우 큽니다. 참조를 얻었다면 확실하게 있는 무엇이기 때문이고 이후 다른 함수를 호출할 때도 참조로 돌아다니게 됩니다. 

동적으로 생성 / 소멸하고 사방에서 참조되는 오브젝트는 당연히 std::shared_ptr을 사용해야 하므로 이 부분은 따로 고려하면 됩니다. 

### 모든 포인터 체크하기 

포인터가 보이면 귀찮아 하지 말고 외부의 조건에 관계 없이 무조건 체크해야 합니다. 이는 C++의 포인터를 사용할 때나 shared_ptr을 사용할 때나 모두 마찬가지입니다.  null이 가능한 언어로 C++이 남아 있는 한 그럴 것입니다.  

Algol 60 언어를 개발한 C.A.R Hoare 가 10억불 짜리 실수였다고 할 정도로 null은 구현과 사용은 쉽지만 엄청나게 많은 문제들을 만들어 낸 원흉이기도 합니다. null 사용이 불가능하고 특수하게 지정해야만 사용이 가능한 언어들도 나오고 있긴 합니다.

만약 nullptr을 bool 과 같은 의미로 사용하는 코드가 없다면 (현재로서는 불가능하지만) 모든 코드에 VERIFY_RETURN( some_ptr)을 추가하는 것으로 포인터 안정성을 확보할 수 있습니다. 따라서, GlobalScripts 관리자 같은 곳에서 포인터를 사용한 게 얼마나 위험한 선택이었는 지를 잘 보여줍니다. 

C++ 11이 나오기 전에 C의 코딩 습관을 갖고 있는 사람(들)이 작성한 코드라 그런 문제가 남아 있지만 논의해서 점점 bool 의미로 사용되는 코드를 줄여 나가서 최종적으로 VERIFY_RETURN() 만으로 가능해지길 기원합니다. 



## Action과 Attribute의 참조형 사용 

참조와 포인터 사용 문맥에서 명확해졌을 것으로 기대합니다. 가장 많이 참조하고 구현하게 되는 두 개 클래스들에 대해 포인터 캐스팅을 매번 쓰게 한건 가장 치명적인 실수였습니다.

이를 개선하기 위한 노력이 있었고 우리가 생각하는 것보다 훨씬 중요하기 때문에 모두 이런 사용 패턴으로 변경하고 싶지만 현실적으로 불가능하기 때문에 눈에 띄는 대로 정리했으면 합니다. 최소한 새로운 코드는 포인터로 Action과 Attribute를 참조하면 안 됩니다. 

```c++
VERIFY_RETURN( GetOwnerPlayer() && GetOwnerPlayer()->IsValid()); // 또는 if 문으로 검증 후 
GetOwnerPlayer()->GetPortalAction().DoSomthing(); // 
```

코드를 읽을 때 편안하고 쓸 때도 더 간결합니다. 꼭 지켜졌으면 하는 부분입니다. 























