# 게임 서버 아키텍처 

전통적으로 세션과 핸들러 기반으로 처리된다.  핸들러는 타잎 기반으로 처리된다. 통신할 때 타잎이 지워지기 때문에 동적으로 타잎을 알 수 있는 필드 값으로 구분한다. 처리는 큐를 통해 역할별 / 지역별 쓰레드로 넘기거나 통신 쓰레드에서 처리하는 방식으로 동작한다. 

메세징 시스템은 좀 더 무거운 구조를 수용한다. 메세지 큐에 문자열 토픽별로 subscribe 하여 사용할 수 있도록 한다. 큐에서 뭔가를 꺼내오면 실행된다. 

액터 모델은 주소 기반으로 동작한다. SALSA가 대표적이다. 주소로 받고 이후 타잎 (패턴) 기반으로 다시 처리하는 구조이다. Mailbox를 두고 한번에 하나의 쓰레드에서만 처리된다는 걸 보장한다. 자식을 갖는 경우 자식까지 하나의 쓰레드에서 실행되는 걸 보장한다. 게임에서 클라이언트까지 액터로 볼 경우 유연성이 매우 높아진다.  

통신과 처리 두 가지가 핵심이다.  통신은 비동기는 필수적이다. 남는 건 주소 기반으로 할 것인지, 타잎 기반으로 할 것인지, 타잎과 컨텐츠 기반으로 할 것인지 결정하는 것이다.  타잎과 컨텐츠 기반은 편리하긴 하지만 성능에 부정적인 영향을 미친다. 게임이 아니라면 메세징 시스템처럼 일반적인 구조 (generative communication)가 나을 수 있다. 

MPI는 그룹 기능이 핵심이다. 과학 계산에 주로 사용되는 시스템으로 슈퍼컴퓨터를 만들 때 사용한다. 액터 모델처럼 프로세스의 동적인 생성과 소멸, 그룹 참여와 통신, 분산 요청과 수집 (Scatter and gather)이 중요한 기능이다. 

## 통신 

수신 : 

- 주소 기반 vs. 타잎 기반 
- 채널 기반 vs. 세션 기반

송신 : 

- 주소 기반 vs. 세션 기반

### 수신 

주소와 채널 기반이면 액터 모델의 통신과 유사하다.  완전한 분산 시스템이며 동적인 시스템이다. 동적인 시스템은 구현이 어렵고 사용할 때 버그가 발생할 가능성이 많다. 

타잎과 세션기반이면 고전적인 방식이다. 이럴 경우 구현도 쉽고 그냥 작성하면 된다. 개별 타잎 핸들러가 복잡해지고 커지는 경향이 있긴 하다. 

타잎 / 채널 기반은 절충형이다.  타잎을 받아서 더 해석하고 필요하면 상태를 보고 다시 전달해야 한다. 

### 송신 

주소나 세션을 찾아서 보내는 두 가지 방법이 있다. 컨텐츠를 보고 어디로 보내야 할 지 결정하더라도 최종적으로는 특정 세션에 보내게 된다. 채널에 보내는 방식을 취할 수도 있는데 이 때는 채널이 주소의 역할을 하게 된다. 

### 채널 기반의 시스템 구성 

node.type.id에서 type.id가 채널의 타잎과 아이디라고 하면 12.8.16 = 40비트 (5바이트) 정도로 주소를 구성 할 수 있다.  충분한 개수가 되고 액터 모델로 처리할 경우 클라이언트를 어떻게 봐야할 지 곤란한 면도 피할 수 있다. 

MPI처럼 process와 group으로 처리하는 방법도 있다. 

너무 다양한 방법이 있어서 결정이 쉽지 않다. 

## 채널, 서비스, 세션 

액터로 처리하면 너무 동적이 되고 관리 대상이 많아지는 측면이 있다.  채널을 갖고 있고 스케줄러에서 실행되는 서비스를 중심으로 타잎 기반 sub/pub 를 수신을 위해 사용하고 서비스 참조와 세션 참조를 통해 통신하는 구조를 선택한다. 

채널은 외부 노드와 클라이언트에서는 모른다. 서비스는 다른 노드와 클라이언트가 알 수도 있다. 서비스를 알면 직접 서비스에 요청을 보내는 메세지를 추가하기 수월하다. 인증과 상태 검증을 거치는 것이 좋으므로 클라이언트의 메세지 타잎들을 처리해 주는 서비스로 구현하는 게 좋다. 

이렇게 보면 서비스 기반으로 처리하고 내부는 채널로 하며 외부는 서비스와 세션 참조로 통신하는 게 나쁘지 않아 보인다. 이 정도로 해도 충분해 보인다.  

타잎 기반으로 sub/pub를 하므로 컨텐츠를 분석해서 보내주는 핸들러들이 필요하게 된다. 이들 핸들러를 편하게 작성하려면 안전한 타잎 변환이 가능해야 한다. 타잎 변환은 두 가지이다. 최종 타잎 또는 상위 타잎의 변환이 필요하다. 최종 타잎은 토픽과 1:1 관계이므로 항상 안전하다. 상위 타잎 변환은 필요한 경우 group에 맞춰 처리한다. 

## Reflection 

https://github.com/RAttab/reflect

IsChildOf() 와 같은 함수를 제공한다. 메세지에 reflection을 포함한다. 디버깅에 사용할 수 있게 한다. 여전히 그룹과 상위 타잎을 맞추는 게 좋을 듯 하다. reflection이 있으면 보다 편하다. 

## 처리 

처리도 service 중심으로 한다. service는 task이며 task_scheduler에서 처리한다.  blocking 처리는 별도의 분리된 쓰레드 풀을 사용한다. 왜냐하면 블럭킹 여부를 판단하기가 애매하기 때문이다. 처리기를 추가하는 건 어렵지 않기 때문이기도 하다. 







