# 게임 서버 분산처리 아키텍처 

전통적으로 세션과 핸들러 기반으로 처리된다.  핸들러는 타잎 기반으로 처리된다. 통신할 때 타잎이 지워지기 때문에 동적으로 타잎을 알 수 있는 필드 값으로 구분한다. 처리는 큐를 통해 역할별 / 지역별 쓰레드로 넘기거나 통신 쓰레드에서 처리하는 방식으로 동작한다. 

메세징 시스템은 좀 더 무거운 구조를 수용한다. 메세지 큐에 문자열 토픽별로 subscribe 하여 사용할 수 있도록 한다. 큐에서 뭔가를 꺼내오면 실행된다. 

액터 모델은 주소 기반으로 동작한다. SALSA가 대표적이다. 주소로 받고 이후 타잎 (패턴) 기반으로 다시 처리하는 구조이다. Mailbox를 두고 한번에 하나의 쓰레드에서만 처리된다는 걸 보장한다. 자식을 갖는 경우 자식까지 하나의 쓰레드에서 실행되는 걸 보장한다. 게임에서 클라이언트까지 액터로 볼 경우 유연성이 매우 높아진다.  

통신과 처리 두 가지가 핵심이다.  통신은 비동기는 필수적이다. 남는 건 주소 기반으로 할 것인지, 타잎 기반으로 할 것인지, 타잎과 컨텐츠 기반으로 할 것인지 결정하는 것이다.  타잎과 컨텐츠 기반은 편리하긴 하지만 성능에 부정적인 영향을 미친다. 게임이 아니라면 메세징 시스템처럼 일반적인 구조 (generative communication)가 나을 수 있다. 

MPI는 그룹 기능이 핵심이다. 과학 계산에 주로 사용되는 시스템으로 슈퍼컴퓨터를 만들 때 사용한다. 액터 모델처럼 프로세스의 동적인 생성과 소멸, 그룹 참여와 통신, 분산 요청과 수집 (Scatter and gather)이 중요한 기능이다. 



## 통신 

수신 : 

- 주소 기반 vs. 타잎 기반 
- 채널 기반 vs. 세션 기반

송신 : 

- 주소 기반 vs. 세션 기반



### 수신 

주소와 채널 기반이면 액터 모델의 통신과 유사하다.  완전한 분산 시스템이며 동적인 시스템이다. 동적인 시스템은 구현이 어렵고 사용할 때 버그가 발생할 가능성이 많다. 

타잎과 세션기반이면 고전적인 방식이다. 이럴 경우 구현도 쉽고 그냥 작성하면 된다. 개별 타잎 핸들러가 복잡해지고 커지는 경향이 있긴 하다. 

타잎 / 채널 기반은 절충형이다.  타잎을 받아서 더 해석하고 필요하면 상태를 보고 다시 전달해야 한다. 



### 송신 

주소나 세션을 찾아서 보내는 두 가지 방법이 있다. 컨텐츠를 보고 어디로 보내야 할 지 결정하더라도 최종적으로는 특정 세션에 보내게 된다. 채널에 보내는 방식을 취할 수도 있는데 이 때는 채널이 주소의 역할을 하게 된다. 



### 채널 기반의 시스템 구성 

node.type.id에서 type.id가 채널의 타잎과 아이디라고 하면 12.8.16 = 40비트 (5바이트) 정도로 주소를 구성 할 수 있다.  충분한 개수가 되고 액터 모델로 처리할 경우 클라이언트를 어떻게 봐야할 지 곤란한 면도 피할 수 있다. 

MPI처럼 process와 group으로 처리하는 방법도 있다. 

너무 다양한 방법이 있어서 결정이 쉽지 않다. 



## 채널, 서비스, 세션 

액터로 처리하면 너무 동적이 되고 관리 대상이 많아지는 측면이 있다.  채널을 갖고 있고 스케줄러에서 실행되는 서비스를 중심으로 타잎 기반 sub/pub 를 수신을 위해 사용하고 서비스 참조와 세션 참조를 통해 통신하는 구조를 선택한다. 

채널은 외부 노드와 클라이언트에서는 모른다. 서비스는 다른 노드와 클라이언트가 알 수도 있다. 서비스를 알면 직접 서비스에 요청을 보내는 메세지를 추가하기 수월하다. 인증과 상태 검증을 거치는 것이 좋으므로 클라이언트의 메세지 타잎들을 처리해 주는 서비스로 구현하는 게 좋다. 

이렇게 보면 서비스 기반으로 처리하고 내부는 채널로 하며 외부는 서비스와 세션 참조로 통신하는 게 나쁘지 않아 보인다. 이 정도로 해도 충분해 보인다.  

타잎 기반으로 sub/pub를 하므로 컨텐츠를 분석해서 보내주는 핸들러들이 필요하게 된다. 이들 핸들러를 편하게 작성하려면 안전한 타잎 변환이 가능해야 한다. 타잎 변환은 두 가지이다. 최종 타잎 또는 상위 타잎의 변환이 필요하다. 최종 타잎은 토픽과 1:1 관계이므로 항상 안전하다. 상위 타잎 변환은 필요한 경우 group에 맞춰 처리한다. 



## Reflection 

https://github.com/RAttab/reflect

IsChildOf() 와 같은 함수를 제공한다. 메세지에 reflection을 포함한다. 디버깅에 사용할 수 있게 한다. 여전히 그룹과 상위 타잎을 맞추는 게 좋을 듯 하다. reflection이 있으면 보다 편하다. 



## 처리 

처리도 service 중심으로 한다. service는 task이며 task_scheduler에서 처리한다.  blocking 처리는 별도의 분리된 쓰레드 풀을 사용한다. 왜냐하면 블럭킹 여부를 판단하기가 애매하기 때문이다. 처리기를 추가하는 건 어렵지 않기 때문이기도 하다. 

이와 같이 통신과 처리를 서비스 중심으로 단순하게 만든다. 서비스는 동적인 것도 포함할 수 있으나 정적인 것들 위주로 한다.  정적이면 디버깅이 쉽다. 그리고 게임 서버에서 충분하다. 동적인 것들은 서비스 단위로 관리한다. 



## 기존 모델 - IOCP 기반 



### 쓰레드 모델 

IOCP 쓰레드 안에서 처리를 함께 하는 방식을 쓴 국내 게임들이 꽤 있다. 락을 걸고 처리하는 방식과 지역별, 기능별로 나누어 큐를 두고 해당 큐를 실행하는 방법으로 락을 피하는 방법이 모두 사용된다. 

애플리케이션 쓰레드를 별도로 둘 경우 IOCP 쓰레드와 스위칭이 더 일어나는데 이 부하를 피하기 위한 것이 주된 근거로 제시된다. IOCP 쓰레드가 자주 깨어나기는 하지만 대부분 블럭킹 상태로 있고 IOCP 전송의 경우 수신보다 10배 가까이 느려 대기하는 시간이 있기 때문에 측정을 하지 않고는 알기 어렵다. 

실제로 그런가? 어떻게 측정할 것인가? 

코어가 8개인 장비에 IOCP 쓰레드 8개, 애플리케이션 쓰레드 8개를 두고 처리를 할 때 애플리케이션 쓰레드가 없는 경우와 비교하여 측정해야 한다. 이미 IOCP 기반인 서버에서 측정을 하면 좀 더 수월할 것으로 보인다. 

IOCP 쓰레드를 사용하는 방식은 실제 Send 호출이 빠르게 처리되는 블럭킹 호출처럼 동작하여 CPU를 제대로 사용하지 못 할 가능성이 높다. IOCP 쓰레드는 커널과 놀게 하고 애플리케이션 쓰레드에서 처리하는 것이 좋을 듯 하다. 측정이 필요하다. 



### 락 vs. 단일 쓰레드  

여러 쓰레드에서 락을 걸면서 처리하는 방식은 R2, 로한에서 보았다. 테라에서도 이런 방식을 사용했다고 들었다. 단지, 기능별 쓰레드 기능이나 메세지별 락 획득과 처리를 외부에서 하고 애플리케이션 코드는 락 없이 처리하는 기능을 추가했다고 들었다. 좀 더 편한 방법일 수 있다. 

락을 사용하고 어려 쓰레드에서 실행하면 락 충돌이 없는 경우 동시성이 올라갈 수 있다. 락 충돌의 분포에 따라 성능 특성은 달라질 것으로 보인다.  주로 락이 거의 없는 처리가 얼마나 되는가가 관건이 될 것으로 보인다. 가장 처리가 많은 이동이나 스킬 사용을 보면 일단 지역에 대한 락을 걸어야 한다. 여기에 공유 락을 사용할 것으로 보이지는 않는다. 그렇다면 락 충돌이 일어나는 범위는 분명히 있게 된다. 

논리, 통계 기반의 분석이 있어야 하지만 지역이나 기능별로 분리하여 단일 쓰레드 모델인 메세지 패싱 등을 사용하는 것보다 빠를 것 같지 않다.  마을에서 개인간 거래나 다른 개인 작업이 많은 경우 외에는 빠르지 않을 듯 하다. 시간이 지나면 락 거는 범위와 처리 시간이 동시에 증가하기 때문에 더 그럴 가능성이 높다. 



## 기존 모델 - 세션 기반 처리 

세션에서 받은 메세지에 대한 핸들러를 처리하면서 대부분의 메세지를 처리하는 방법이다. 클라이언트에서는 대부분 이런 방식을 사용하고 오래된 서버들도 이런 방식을 사용한다. 

클래스 추가나 이런 걸 하지 않고 핸들러에서 주욱 서술하는 경우가 많다. 이는 클래스로 전달을 받더라도 동일하게 되는 경우들이 많다. 단일 책임 원칙에 따라 클래스를 분할하고 처리하는 것이 필요하다. 그렇지 않으면 상태 변수들이 섞이면서 코드가 해독 불가능할 때까지 복잡도가 올라간다. 

세션은 IO와 연관되어 있기 때문에 쓰레드 모델 개선과 같은 작업들이 어려워진다. 메세지는 큐를 통해 분리하고 처리하는 것이 좋다. 



# 정리 

채널과 서비스 기반으로 분산처리 아키텍처를 구성한다. 

액터 모델로 세션까지 추상화시키고 메세지의 필드 기반으로 디스패칭하는 강력한 기능들은 멋져보이긴 하지만 실제 구현에서 게임과 맞지 않는 부분이 많이 있을 수 있고 구현 난이도도 굉장히 올라간다.  

디버깅이 쉽고 간결한 모델에서 시작한다. 다양한 편의 기능을 추가하고 좋은 상위 개념들을 풍부하게 만든다. 

그리고, 좋은 게임들을 만든다. 





