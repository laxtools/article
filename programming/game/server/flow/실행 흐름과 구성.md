# 실행 흐름과 구성 

서버의 실행 흐름과 구성 (Composition)은 게임 컨텐트 개발의 핵심이다. 실행 흐름이 명확하게 잘 보이고 기능별로 잘 나눠져 쉽게 구현 가능해야 한다. 



# 기본 방향 

기능 단위로 잘 분할 되어야 한다. 분할된 단위는 연결이 최대한 약하여 개별적으로 변경이 가능해야 한다. 게임은 인공물 중의 인공물로 기획자나 사용자가 원하는 방향으로 변경이 매우 큰 시스템이기 때문에 변경을 수용하면서 전체 시스템이 안정되어야 한다. 

Unity와 Unreal 4, 그간의 게임 개발 경험에서 보면 다음의 방향이 괜찮다. 

- 정적인 서비스 단위로 기능 분할 
  - 쓰레드 풀을 갖는 스케줄러에서 실행 
- 오브젝트 / 액터 / 컴포넌트 
  - 서비스 내에서 실행
  - reflection
  - shared_ptr (ref)
- 룰 기반 전이를 갖춘 HFSM 
  - 컴포넌트들의 활성화 / 비활성화로 구현 가능 
- signal 전파 
- 메세지와 타이머 기반 실행 



오브젝트에 reflection, 레퍼런스 관리, signal 기능을 포함한다. actor를 능동형 오브젝트들로 하고 컴포넌트를 갖는다. 예를 들어, 아이템과 스킬은 오브젝트이고 캐릭터와 NPC는 actor이다.  컴포넌트도 오브젝트이다. 



## 정적인 서비스 단위로 기능 분할 

쓰레드에서 실행되는 단위가 동적으로 변할 경우 관리가 어렵다. 서비스는 다른 서버에서도 알아야 할 필요가 있어 동적이면 불안정한 분산 처리의 원이이 될 수 있다. 따라서, 동적인 부분은 서비스 내부로 가져와 서비스 단위로 관리하고 전체 구성은 정적으로 만들어 구현과 디버깅이 쉽게 만든다. 

서비스의 예로 scene_manager_service, scene_runner_service가 있다. manager에서 runner들,  scene의 생성과 소멸을 처리한다. scene_runner_service는 정적으로 여러 개 실행된다.  

service는 task로 스케줄러에서 실행된다.  service는 net::service의 채널과 다른 service의 채널을 통해 필요한 메세지를 받는다.  



## 오브젝트 / 액터 / 컴포넌트 

오브젝트는 reflection이 가능하고 동적으로 타잎을 참조할 수 있으며 shared_ptr을 ref 타잎으로 갖는다. 생성과 소멸, 나이를 알 수 있도록 한다. 큐 형태의 풀에서 타잎별로 재사용 가능하게 한다. 오브젝트는 시그널을 주고 받을 수 있으며 등록과 해제를 관리하는 도구(함수)를 갖고 있다. 

액터는 컴포넌트를 갖는다. 능동적으로 타이머를 갖고 실행되며 메세지와 연결된다. HFSM이나 BehaviorTree(BT)와 연결된다. 이를 기반으로 데이터와 연동된 AI를 실행할 수 있다. 

타이머는 서비스에서 갖는다. 오브젝트와 액터는 서비스 문맥에서 실행되며 나의 서비스를 알고 있다.  



# 프로토타잎 

- 서비스 
- 오브젝트 
  - reflection
  - signal 
- 액터 
  - 컴포넌트 
  - 메세지 
  - HFSM 또는 BT 



위의 구성은 통신과 무관하게 동작한다.  메세지는 channel 수준에서만 의미를 갖는다. 컨텐츠 구성은 컴포넌트 이하 단에서 개별 컨텐츠에 맞게 구성한다. 



## reflection 

리플렉션 라이브러리들 테스트. rttr 우선 진행. 



## signal 

시그널 라이브러리 테스트. 함수와 아이디 기반 콜백 테스트.  타이머 등에 활용 가능한 지 확인. 



## component 

- activate
- deactivate 
- 다른 컴포넌트 참조 



auto mc = get_comp("move"); 

return_if( !mc, fail_component_not_found ); 



## 판단과 행동의 구성  

C++ 코드 내부와 데이터로 구성된 외부 정의에 따라 판단하고 행동하게 만들 수 있어야 한다. 두 개가 부드럽게 캐릭터와 NPC를 포함하여 처리될 수 있어야 한다.  지금까지 본 바로는 완전하게 두 가지를 통합한 경우는 없었다. 

이런 구성 방법 중 HFSM과 Behavior Tree가 대표적이다. if 문으로 구성하는 경우도 있지만 데이터화가 필요할 경우 두 가지 방법 중 하나를 사용한다. 둘은 동일한 실행을 구성할 수 있기 때문에 본질적으로 같다. 

### HFSM 

HFSM은 FSM의 상태를 개념으로 계층화 한 구조이다. 예를 들어, 이동을 전투 상태와 평화 상태의 하위 상태로 두어 재사용하는 방법으로 상태의 개수를 간략하게 만든다.  전투 상태는 전투에서 기본적으로 처리해야 할 것들, 평화 상태는 평시에 해야할 것들을 처리함으로써 다른 상태들의 부담을 덜어준다. 

HFSM은 Pc, Npc에 모두 적용 가능하다. 상태를 구분함으로써 신경 써야 할 부분을 많이 줄여주는 장점이 있다. 플레이어의 경우 항상 처리해야 할 내용이 많기 때문에 항상 실행되는 상태가 필요하다.  최상위 상태나 기본 클래스에서 처리할 수 있다.  컴포넌트와 연결하여 처리하는 구조가 필요하다. 

HFSM의 상태 전이가 조건에 민감한 경우가 많다. 이를 시그널 / 이벤트로 만들고 해당 시그널 / 이벤트에서 상태 전이를 데이터로 처리함으로써 상태 전환 그래프를 만들 수 있다.  상태의 시작과 종료 시에 조건에 따라 데이터를 지정함으로써 추가적인 판단과 처리를 지정할 수 있다. 



### Behavior Tree (행동 트리, BT) 

행동 트리는 AI와 궁합이 잘 맞는다.  Sequence, Selector, Decorator, Task로 구성된다. 각 노드는 성공, 실패, 실행을 돌려준다. 실행 중인 노드가 있으면 해당 노드가 계속 실행된다.  실행 중인 노드가 없으면 루트부터 실행한다. 

Task는 마지막 단말 (leaf) 노드이다.  Sequence는 성공하면 다음 노드를 계속 실행한다. 실패하면 실패를 리턴한다. Selector는 처음 자식부터 성공하는 노드가 있을 때까지 실행한다. 없으면 실패한다. Task는 특정 작업을 실행한다. 

Decorator는 결과를 바꾸는 Inverter, 항상 성공 시키는 Succeeder, 반복 시키는 Repeater 등이 있다. 아이디어에 따라 추가할 수 있는데 대부분 이 정도로 충분하다. 

Task에 Condition을 추가하면 여러 가지 실행 제어를 쉽게 할 수 있다. 이는 Decorator로 만들어도 된다.  

BT는 상태 변경이 자유롭지 않고 실행을 통해 선택하기 때문에 Task의 그래프 변경을 위해 블랙보드와 같은 변수를 사용하여 노드 간의 선택을 추가 제어한다. 



## 컴포넌트 

타잎을 사용하여 구성하는 역할을 컴포넌트에서 한다. 판단과 행동에 직간접적으로 연결된다. 판단해서 스킬을 시전하거나 아이템을 사용하거나 하려면 컴포넌트를 써야 한다.  어떤 상태나 행동은 컴포넌트의 실행을 멈춰야 한다. 



## 통합 

조건에 따라 구성 가능한 행동으로 BT는 중요하다.  상태의 분류와 행동의 제어는 필요하다.  상태가 분류되지 않으면 집중이 어려워지고 코드도 복잡해진다. 따라서, 두 가지를 통합하고 구체적인 행동을 BT로 하는 것이 좋을 듯 하다. 

- 큰 상태 관리는 HFSM으로 한다. 
- 개별 상태의 동작을 필요시 BT로 구현한다. 



HFSM은 상태 전환을 시그널 (이벤트)에 따라 진행한다.  HFSM이 알아야 할 signal 들을 다른 코드에서 actor를 통해 전달한다. 

BT는 함수 호출과 변수 지정을 핵심 기능으로 한다.  함수들을 많이 만들어주면 BT의 판단이 좋아지도록 한다. 함수 호출은 일반화되면서 빠른 구조를 찾는다. 



































