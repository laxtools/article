# 서버 통계 모니터링 

현재 사용하는 메모리, 분당 패킷량, 사용자 수, 인스턴스 개수, 특정 인스턴스의 오브젝트 개수. 보고 싶은 정보는 많다. 이런 정보를 서비스 별로 모아서 보여주는 구조가 가장 효율적으로 보인다. 정보를 만들거나 사용하는 곳이 정보를 가장 잘 알기 때문이다. 

구현을 한다고 하면 다른 접근이 필요하다. 만약 분당 패킷량을 조회하고 싶다면 어딘가에서 관리를 해야 한다. 이 정보를 조회하고 전달하고 하는 기능도 구현해야 한다. 정보를 모으는 것과 조회하고 전달하는 과정은 다르다.  굳이 정보를 아는 곳에서 전달까지 구현할 필요는 없다. 

다른 면에서 하나의 구조로 모아서 전달해 주는 게 가능하다면 개별 구현이 없어도 된다. 정보를 만드는 곳에서 전달만 해주면 수집하고 가공하고 전달하는 건 별도로 해주면 된다. 구현도 역할별로 나누어지니 편할 것이다. 

정보를 지정해야 하는 경우는 좀 다르다. 이런 기능은 정보를 아는 곳에서 직접 접근해서 변경해줘야 한다. 게임 서버에서 이런 기능은 GM 기능으로 치트라는 이름으로 구현되어 왔다. 



## 구조 

argos_service 

- 모니터링 서비스이다. 
- 수집, 통계, 전달 기능을 구현한다. 



사용은 다음과 같이 한다.  

```c++
service::ref argos = server::get( argos_service::name ); 

argos->send( msg ); 
```



oid는 16비트 4레벨 정수 배열이다.  이를 키로 보관하고 돌려준다.  하위 레벨 전체를 가져올 수 있도록 구조를 잡는다. 

L1, L2, L3, L4로 나눠서 인덱스로 동작한다. L4만 값을 갖는다. 특정 L3 전체를 가져올 수 있다. json 문자열로 만들어 전달한다. 조회하는 곳은 파싱해서 사용한다.  



# MIB 정의 

SNMP MIB (Management Information Base) 용어를 사용한다.  문자열에서 OID로 변환 가능하게 한다. 게임 별로 MIB 정의는 다를 수 있으며 구성 파일이나 CSV와 같이 게임에서 이미 구현한 정보 지정 방식을 사용한다. 

몇 가지 예를 들면 다음과 같이 정의할 수 있다. 

legend.user.stat.current_users                                           3.1.1.1

legend.user.stat.login_count                                               3.1.1.2

legend.world.instance.current_count                                3.3.1.1

legend.world.instance.total_created_count                      3.3.1.2



위 정보를 생성하기 위한 메세지와 핸들러는 게임별로 구현해야 한다. 메세지 처리 등과 연계 되므로 개념만 유지하고 구현은 게임에 맞게 해야 한다. 더 나은 방법이 없을까? 



## 일반화 가능성 

모든 게임에 적용 가능한 구조를 생각해 본다. 







# 자료구조 

- 1안) lockfree hash table. 
- 2안) queue를 통한 전달과 단일 쓰레드 update

메모리 추적과 같이 매우 빠른 처리가 필요한 경우가 아니라면 서비스로 만들고 메시지로 처리하는 것이 일반화하기 좋다. 



