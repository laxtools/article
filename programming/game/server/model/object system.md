# object system 

게임은 다수의 오브젝트를 다룬다. Item, Pc, Npc, Skill 등이 주 대상이다.  이들을 object와 actor로 나누고 actor는 컴포넌트를 갖도록 하며 서로 시그널로 이벤트를 받을 수 있도록 한다. 또 라이프 사이클을 관리하고 필요하면 빠르게 풀에서 할당 / 해제 가능하도록 한다.  reflection을 포함하여 로깅이 가능하도록 한다.  적절한 성능을 갖도록 한다. 

오브젝트 상태는 시각화가 가능하도록 한다. 이를 바탕으로 디버깅 가능한 서버를 만든다. 오브젝트 시스템은 통신, 서비스, 데이터, 공간, DB 처리와 함께 서버의 핵심 기반이 된다. 

데이터 사용과 통신을 고려하여 진행해야 한다.  타이머와 메세지 처리도 함께 고려한다. 좀 비대해질 가능성이 있으므로 기능을 나눠야 할 수 있다. 



## 목표 

- 컨텐츠 개발 효율 
- 안정성
- 디버깅 
- 성능

오브젝트 시스템의 목표는 빠른 컨텐츠 개발에 있다. 게임은 변경이 많은 시스템이고 MMORPG는 더 심하다. 얼마나 빠르게 다양한 컨텐츠를 제공할 수 있는 지에 따라 성패가 갈린다. 이를 가능하게 하려면 안정적이고 디버깅이 쉬워야 하고 성능도 보장해야 한다.

서버는 통신, 처리, 컨텐츠 개발에서 다양한 관점의 차이가 있다. 해결하려는 문제는 단순한데 접근은 다양하니 아직 해결된 문제가 아니라고 할 수 있다. 논란이 되는 부분도 있고 확정된 부분도 있다. 방향이 비슷한 사람도 있으니 해결이 멀지 않은 듯 하다. 



## 문제들

엔티티 / 컴포넌트 시스템 (ECS)로 접근하는 경우가 많다. 배경이 되는 이론들도 약하긴 하지만 있고, 언리얼이나 유니티와 같은 클라이언트 엔진에서 엔티티 (액터/게임 오브젝트)와 컴포넌트를 사용하는 경우들이 있다. 하지만, 이런 경우에도 OOP 클래스로 구성된 큰 시스템에 기반하여 사용과 데이터, 장면(월드) 내 배치되는 오브젝트 중심으로 구성된다. 

ECS의 어떤 접근에서는 엔티티는 ID로만, 컴포넌트는 데이터만, 시스템에서만 동작을 넣는 걸 강조하는 경우가 있다. 하지만 현실은 이렇게 단순하게 해결되지 않는다. 

컴포넌트가 많은 일을 하면 재사용이 불가능해지고 ECS의 장점이 줄어드는 건 명확하다. 엔티티의 상속을 허용하고 데이터 추가는 막아서 디버깅과 컴포넌트 구성이 보다 명확하도록 하고, 컴포넌트는 컴포넌트 자체의 데이터 변경과 시그널 전파, 시스템 호출만 허용하는 제약을 두고 진행해 보는 게 좋을 듯 하다. 

컴포넌트는 여러 클래스를 갖는 외부 인터페이스로 두고 (컴포넌트 폴더에 클래스들을 둔다) 제한을 갖게 한다면 어떨까? OOP 설계는 여전히 유효하며 강력한 도구이다. 



# 방향 

- entity는 변수 없이 상속만 갖는다. 
  - 상속된 클래스에서 컴포넌트를 생성한다. 
- 컴포넌트에 제약을 둔다
  - 자기만 참조하는 처리
  - signal emit 
  - 시스템 호출 
- 시스템 
  - 여러 엔티티 참조
  - 여러 컴포넌트 참조
  - 여러 시스템 참조 

위와 같이 잘 처리되지 않는다. 관계가 게임의 핵심이기 때문이다. 커플링이 가장 강한 기획을 갖기에 커플링이 작은 시스템을 만드기 쉽지 않다. 게임 서버 개발의 가장 매력적인 부분이다.  오히려 잘 보이게 모아 두는 게 중요하다. 시스템 정도로 큰 단위는 아니다.

위에 더하여 상태와 행동을 제어하는 기능이 같이 포함되어야 한다. 전체 시스템을 데이터로 구성할 수 있어야 한다. 



# 시그널 

simplesignal을 테스트 했다. 람다 함수로 동작한다. 간단한 북키핑 (signal_link ring)이 있다. 성능도 괜찮고 C++ 11에서 가장 간단한 구성이다. 



## 애슐리 엔티티 프레임워크

https://github.com/SgtCoDFish/AshleyCPP

java에서 유명한 프레임워크의 c++ 포팅이다. 컴포넌트, 시그널, 오브젝트 풀을 포함한다.

c++ type_index로 오브젝트들을 관리한다. Entity의 하위 클래스는 허용하지 않고 컴포넌트와 시그널 처리로 이루어져 있다. 서버에서 사용하기 위험해 보이는 코드들도 있다. 수정은 필요해 보이고 아이디어 중심으로 활용하는 게 좋아 보인다.  

###std::type_index

typeid로 얻는 type_info는 컨테이너 키로 사용할 수 없다.  타잎 정보를 저장하고 찾기 위해 필요한 구조를 만들기 위해 사용한다. 

AshleyCPP는 type_index로 RTTI를 구성한다. 



































