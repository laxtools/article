# 충돌 정보 간략화 

클라이언트에 물리 정보를 포함할 때도 있으나 대부분 매시를 충돌에도 사용하고 있다. 장비 성능이 좋아져 그냥 사용해도 괜찮다면 좋은 방법일 수 있다. 서버용 충돌 정보를 수작업으로 만들기 보다 클라이언트 매시 정보에서 생성하고 간략화 과정을 통해 빠른 충돌 처리가 가능하도록 하면 좋다. 

이를 위해 여기서 몇 가지 아이디어를 논문을 통해 살펴보고 구현할 방향을 정리해 둔다. 



# 논문 - Bounding Proxies  

목표가 간략화에 있지는 않지만 좋은 개념들을 포함하고 설명도 자세하여 읽어 두고 이해하면 아이디어를 구체화하는 데 큰 도움이 될 듯 하다. 



## 도입 

프록시란 말이 자주 나온다.  Proxy geometry는 원래 기하구조를 대신하는 것으로 여기서는 원래 기하구조의 위상구조와 함께 간략화된 구조를 뜻한다. 원래 모양이 어느 정도 유지되도록 하는 방법이다.  모든 방법이 이를 목표로 하나 용도에 따라 전혀 다를 수도 있다. 

- coarse, closed 2-manifold triangle mesh 

원래 보다 적은 정보를 가진 (모양이라 더 거칠게 표현되므로 coarse를 사용), 삼각형 매시를 표면을 갖고 닫혀 있는 면이라는 뜻이다. 2-manifold는 2차원 다양체라는 뜻이다.  2차원은 면이라는 뜻이고 다양체라는 뜻은 작은 부분에서 평면과 해석적으로 거의 같다는 뜻이다.  그냥 닫혀있는 매시라고 생각하면 된다. 

- bounding property 

원래 매시를 둘러싸는 속성이다. 이를 유지하는 방법을 사용한다. 서버에서 충돌을 처리할 때는 꼭 필요한 속성은 아니다.

논문에서 제시한 바람직한 속성은 다음과 같다. 

- bounding 
- coarser
- tight 
- geometry adaptive
  - 매시를 반영 
- user adaptive 
  - 선택 가능하고 생성을 제어



복록 모양에 대해서는 빠른 충돌 처리가 GJK로 가능하나 임의의 모양이면 충돌 계산량이 많아지므로 이를 반영해야 한다. 

- convexity 
  - division allowed

볼록하면 서로 가장 가까운 점, 면, 선만 점검해도 충돌 여부를 알 수 있다. 

충돌 구현을 살필 때 정적인 오브젝트들의 최적화에 대해 좀 더 고민해야 한다. 







# GJK 알고리즘 

https://en.wikipedia.org/wiki/Gilbert%E2%80%93Johnson%E2%80%93Keerthi_distance_algorithm

밍코브스키 합을 사용. 

## 함수들 

Support(shape, d) : d와 최대 내적을 갖는 점을 돌려줌

NearestSimplex(s) : simplex s에서 원점에 가장 가까운 심플렉스와 a direction toward the origin normal to the new simplex를 돌려줌.  s가 원점을 포함하면 s를 받아들이고 두 개의 모양은 겹친다. 



## 대략의 코드 

```pascal
function GJK_intersection(shape p, shape q, vector initial_axis):
       vector  A = Support(p, initial_axis) - Support(q, -initial_axis)
       simplex s = {A}
       vector  D = -A
       loop:
           A = Support(p, D) - Support(q, -D)
           if dot(A, D) < 0:
              reject
           s = s ∪ A
           s, D, contains_origin = NearestSimplex(s)
           if contains_origin:
              accept
```



## 심플렉스

삼각형이나 사면체를 다차원으로 일반화한 개념이다.  k-simple는 k 차원의 polytope로 k+1의 꼭지점을 갖는 볼록한 모양이다. 

$u_0, u_1, ..., u_k \in R^k$ 가 affinely independent일 때, 즉, $u_1 - u_0, u_2 - u_0, u_k - u_0$가 일차 독립일 때, 심플렉스는 다음을 만족하는 점들이다. 

$$ C = \{ \theta_0 u_0 + ... + \theta_k u_k | \sum_{i=0}^{k} \theta_i = 1 \land \forall i \theta_i \ge 0  \   \} $$ 

쎄타 값의 합을 1로 하는 건 내부와 표면을 다 포함하는 영역을 만들기 위한 일반적인 방법이다. 

위와 같이 보면 점, 선분, 삼각형, 사면체가 모두 심플렉스에 해당한다. 



## 알고리즘의 이해 

https://www.haroldserrano.com/blog/visualizing-the-gjk-collision-algorithm

감동적인 말이 있어 적는다. 엔진 자체는 연습용이라 할 수 있다. 마인크래프트도 그랬다. 더 해나가길. 

```
Not only did it improve my coding skills, but it taught me the meaning of perseverance and consistency
```



### Supporting Point 

볼록한 모양에서 주어진 방향과 가장 먼 점을 지지점이라고 한다.  



### Minkowski Sum and Difference

밍코브스키 합과 차가 있다. 

$A \oplus B$ 는 모양 A의 각 점에 B를 올려놓고 외곽선을 따라 전체를 다 이동시킨 모양이다. 

$A \ominus B$ 는 $A \oplus -B$ 와 같다. 

밍코브스키 차가 원점을 포함하면 둘은 겹친다. 



#### 위키피디아의 정의 

A와 B가 유클리드 공간의 점 벡터 집합이라고 할 때, 

$ A + B = \{ a + b | a \in A, b \in B \}$ 

차는 다음과 같다. 

$A-B = \{ c | c + B \subset A\}$

위의 정의가 좀 이상해 보일 수 있지만 벡터 식으로는 $ A + (-B)$ 와 같다. 단지, 예외적인 경우가 발생한다. 

반례는 A = [-2, 2], B = [-1, 1]일 때, A - B = [-1, 1]이고 A + (-B) = [-3, 3]이다. 



### GJK 알고리즘 

- 두 개 Convex 모양의 밍코브스키 차를 만들고 S라고 한다. 
- S 상의 임의의 점을 하나 선택하고 A라고 하고 심플레스 집합 Q에 넣는다.  Q = {A}
- -A 방향과 가장 멀리 있는 (Supporting Point)인 B를 선택하고 Q에 넣는다. Q = { A, B}
  - -A는 그림에서 점 A에서 원점 방향의 벡터이다. 
- Q 상에서 원점과 가장 가까운 점 C를 찾는다. C가 Q 상에서 의미 있기 위해선 A, B 모두 필요하므로 둘 다 유지한다. 
- -C 방향에서 가장 멀리 있는 S 상의 점 D를 찾아 Q에 넣는다. Q = { A, B, D}
- 이제 Q 상에서 원점과 가장 가까운 점은 E가 된다.  E를 Q에서 나타내기 위해 필요한 점들은 B와 D만이므로 A를 Q에서 제거한다. Q = { B, D}. 
- -E 방향의 지지점은 S상에서 F이고 Q에 넣는다. Q = {B, D, F}
- 이제 Q 상에서 원점과 가장 가까운 점은 G이다. 
- D, F만 있으면 G를 표현할 수 있으므로 다른 점들은 제거한다. Q = { D, F }
- -G 방향으로 S 상에서 G보다 더 가까운 점이 없으므로 충돌이 없는 것으로 처리된다. 



잘 이해가 안 되는 부분은 다음과 같다. 

- Q에서 원점과 가장 가까운 점을 표현할 수 있는 점들만 남기는 이유는? 

  이 부분이 좀 이상하다. NearestSimplex(s) 함수를 구현할 수 있는가? 

  

- 최적화가 가능해 보인다. 

  - 어떤 지점인지 생각을 계속 한다.

![gjk_viz](D:\laxtools\article\programming\game\server\spatial\collision\gjk_viz.jpg)





