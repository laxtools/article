# 게임 서버 과제

80%의 서버 작업은 반복된다. 게임에 따라 세부 구현이 달라지는 부분이 많아 보이지만 패턴 자체는 반복된다. 이렇게 반복되는 과제를 정리하고 각 과제의 요구 사항과 패턴을 만들어두면 개별 게임 개발을 효율적이고 안정적으로 진행할 수 있따. 

## 분산처리 

### 통신 

실시간 분산 시스템으로서의 게임 서버에서 기본은 통신이다. 통신은 Tcp 기반으로 빠르고 안정적인 코드를 확보하면 80% 이상 기능이 확보된다. 

좋은 통신 라이브러리가 많이 있으며 다음과 같다. 

- boost.asio 
  - epoll, kqueue, select, iocp wrapper 
  - 안드로이드, ios, Linux, Windows 호환
- libuv 
  - node.js의 core c 라이브러리 
  - 비동기 통신
  - 안드로이드, ios, Linux, Windows 호환
- zeromq
  - iocp를 지원하지 않지만 Linux 계열에서 좋은 상위 소켓을 제공

그외 많은 라이브러리가 있으나 

### 메세지 

게임은 일정한 정보를 담은 메세지로 통신한다. 길이를 갖는 바이너리 메세지가 일반화된 형태이다. json을 사용하는 경우도 있으나 바이너리 메세지의 하위 프로토콜로 볼 수 있다. 

메세지 처리를 위해 플래폼, 언어 호환이 되도록 하는 serialization / deserialization 기능이 필요하다. 호환성을 위해 IDL (interface definition language)로 메세지를 정의하고 각 언어로 변환해주는 라이브러리들이 있다.

- protobuf 
- flatbuffers 
- thrift
- bitsery 
- yas

bitsery와 yas는 언어 호환을 제공하지 않고 c/c++만 지원한다. 대신 빠르다. 

probuf가 가장 범용적이며 flatbuffers는 속도가 빠르다. flatbuffers는 사용이 번거로운 측면이 있다. thrift는 적절한 성능에 편리한 사용성을 제공한다. 

c++ 클라 / 서버 환경이라면 bitsery, yas 모두 좋다. 

#### Subscription / Dispatching Chain 

게임 서버 마다 다른 방법을 사용한다. 메세지의 타잎에 따라 처리 루틴을 호출하고 해당 루틴에서 최종 사용처로 보내는 방법도 있고 channel을 만들고 해당 채털에 타잎이나 조건에 따라 처리 루틴을 등록하는 방법도 있다. 

Go 언어에서는 channel을 사용한다. CSP가 channel을 따라 구성된다. Actor 모델은 Actor의 reference를 갖고 처리한다. 개별 메일박스 또는 큐를 갖는 액터 모델은 참조(주소)로 통신하는 방법이다. 

어떤 방법을 사용하건 동작하지만 하나를 선택하여 미리 잘 다듬어 둘 필요가 있다. 

### 처리 

처리는 한국의 게임 서버들의 경우 iocp 쓰레드에서 lock을 사용하는 shared state multithreading이 많이 채택되었다. 락 관리의 번거로움과 데드락 등의 안정성 이슈와 node.js 와 같은 비동기 처리 프레임워크의 확산, MPI와 같은 메세지 전달 처리, 액터 모델과 CSP (Communicating Sequential Process)의 영향으로 단일 쓰레드 비동기 처리 모델을 기반으로 하는 게임들이 늘어나고 있다. iocp 쓰레드를 처리에 사용하는 경우에도 지역별 단일 쓰레드 방식을 많이 사용한다. 

느슨한 액터 모델이나 CSP 모델을 사용하는 게임 서버들이 늘어날 것으로 보이고 특수한 경우가 아니라면 대부분 메세지 전달 처리 방식이 메인 스트림이 될 것으로 보인다. MMORPG의 대규모 공성전과 같은 경우가 아니라면 모두 동작할 것으로 보이며 인접 지역의 메세지 / 오브젝트 proxy 개념으로 처리하는 게임들도 있다. 이 부분은 단일 쓰레드 모델의 중요 과제 중 하나로 남아 있다. 

### 분산

분산은 확장성을 확보하여 전체 시스템의 성능을 보장하기 위해 중요하다. Irony 한 상황은 MMORPG보다 MORPG가 확장성이 더 중요하다는 점이다. MMORPG도 현재처럼 완전히 DB가 분리된 월드 보다 통합된 월드를 제공할 필요가 있기 떄문에 기획과 기술적인 과제로 남아 있다. 

분산은 수용 가능한 사용자 수를 늘리는 것이 핵심 목표이며 하나의 모델은 다음과 같다. 

- 사용자를 받는 front 서버들
  - backend 서비스와 연동 
  - lobby 서비스 
  - 게임 인스턴스 실행 
- 서비스를 제공하는 backend 서버들
  - 가상 월드 서비스 
  - 매칭 서비스 
  - 인증 서비스 
  - 길드 서비스 

Front와 Backend를 서비스로 나누어 처리하고 Front를 게임 인스턴스 중심으로 확장의 핵심으로 활용하는 방법이 복잡도를 줄이면서 확장성을 확보하는 하나의 좋은 방법으로 보인다. 

분산에서 데이터베이스의 분산 처리가 중요하다. 데이터베이스의 분산은 키 기반 분산이 가장 단순하며 잘 동작한다. user 단위로 고유한 키를 배분하고 데이터베이스를 선택할 수 있도록 하는 방법으로 분산 시킬 수 있다. 분산 트랜잭션은 애플리케이션 단에 2 phase commit을 구현하여 처리한다. 

분산 처리는 매번 구현하기 부담스러운 부분으로 안정적인 모델을 하나 갖추고 재사용할 수 있또록 해야 한다. 데이터베이스를 포함하는 것이 필수적이다. 

#### 서비스 장애 처리 

분산된 서비스의 특정 기능이 동작 하지 않을 때 이에 대응하는 처리가 필수적이다. 위의 front / backend 서비스 분산 모델의 경우 실행 중인 게임들은 데이터베이스 오류가 없다면 계속 실행 가능하다. 인증, 매칭, 길드 등은 일시적으로 장애가 있을 수 있으며 복구 시간이 길지 않다. 

월드 서비스의 경우 복구 과정을 포함하는 것이 필요하다. 월드 서비스의 기능을 최소화 하고 복구가 가능하도록 하면 서비스 장애율을 최소화하고 유지보수가 매우 편하게 될 수 있다. 

서비스 간의 의존 관계를 최소화하고 작은 서비스 단위로 분리하고 중요 서비스는 복구 가능하게 한다. 위를 포함한 코드 기반을 갖추어야 개별 게임 개발이 효율적일 수 있다. 없다면 매번 만들게 된다. 



## 데이터 

### 데이터베이스 

게임의 오브젝트는 DB 입장에서 보면 단순한 경우가 많다. 이들 오브젝트가 갖고 있는 특성에 기반하여 DB 처리를 자동화하는 것이 필요하다.  캐릭터와 연결된 데이터는 레코드와 레코드의 맵 형태이다.  길드 등도 오브젝트와 연결된 레코드와 레코드의 맵 형태이다. 

이를 매핑하고 로딩과 저장을 할 수 있는 프로시저를 생성하고 게임 코드를 생성하는 도구를 갖춘 구조로 발전시켜야 한다. 데이터베이스 처리라기 보다는 게임 오브젝트의 영속성을 처리한다는 개념으로 처리해야 한다. 

지금까지 MMORPG 개발에서 보면 함수 단위 처리가 꽤 많다. 기본 기능은 있지만 개별로 개발을 하는 게 좋을 경우도 많다. 이럴 경우 IDL 형태로 프로시저의 내용은 남겨두고 in/out만 명시하는 형태로 개발할 수도 있을 것이다. 

어디까지 가능할 지 모르나 최대한 진행해서 확보하는 게 필요하다. 

### 게임 데이터 

게임의 내용을 구성하는 테이블 형태의 데이터와 함께 스크립트 성격을 갖고 행동을 결정할 수 있는 if 구조를 포함한 데이터를 정의하고 로딩과 사용 코드를 생성하는 도구를 갖춘 구조를 개발해야 한다. 



## 배포와 유지보수 





