# game data ide 

그간 익숙하게 하던 방식의 데이터 제작 흐름인 엑셀과 csv 중심으로 보고 있었다. tableau에서 보여지는 데이터 탐색 기능과 실제 운영 툴, elastic 스택의 데이터 검색 기능을 보면 다음 차원의 데이터 제작 흐름이 만들어져야 한다는 걸 강하게 시사한다. 뭔가 새로운 변화와 도전이 필요하다. 



# Tableau 

매우 인상적이다. 데이터 분석과 시각화를 결합하여 사람이 이해할 수 있는 데이터 분석을 진행할 수 있게 한다. R이나 파이썬으로 하는 데이터 분석보다 훨씬 직관적이며 대중적으로 사용 가능하다. 이와 같은 시스템의 구축이 기업 차원에서 필요하다. 게임에도 마찬가지로 필요하다. 노력을 최소화하면서 구성 가능한 데이터 제작과 분석 IDE가 필요하다. 

게임 데이터 IDE를 만들려면 데이터를 좀 더 이해해야 한다. 게임 데이터를 어떻게 이해할 수 있을까? 기존 게임들의 데이터와 서비스 중 생성된 DB, 로그 데이터를 봐야 한다. 그리고 연습을 많이 해 보아야 한다. 직관이 생기면 개념을 만들고 도구를 만들 수 있다. 



## 경쟁자들 (대안들)

https://www.softwareadvice.com/bi/tableau-alternatives/



# 게임 데이터 이해 

게임 데이터는 두 가지 분류가 있다. 

- 시뮬레이션의 입력 데이터 
- 시뮬레이션의 결과 데이터 

입력 데이터가 전통적으로 엑섹로 작업하고 최종 형식으로 export 하여 게임에서 사용하는 데이터이다.  결과 데이터는 시뮬레이션의 영속성을 위해 DB에 저장되는 데이터들이다. 

게임을 시뮬레이션 시스템으로 보고 입력으로 조정하고 결과로 저장되는 데이터를 살피는 역할을 게임 IDE가 수행한다. 시뮬레이션이 정확하게 구현되어야 IDE가 의미가 있다.  결과와 직접 연결되지는 않지만 규칙으로 사용하는 입력 데이터도 있다. 

게임 데이터, 특히, RPG 데이터를 이해하려면 시뮬레이션 게임을 만들어야 한다. 특정 게임의 시뮬레이션 게임을 만들려면 어느 정도의 노력이 필요한 지, 어떻게 데이터를 설계해야 하는 지 파악해야 한다. 좋은 연습 문제이자 게임의 데이터 특성을 이해하는 좋은 시작이다. 



# RPG 시뮬레이션 게임 

모델과 게임 두 가지 방향에서 진행한다. 모델링은 미시적 차원, 거시적 차원에서 모두 진행하여 분석 가능하게 한다.  게임은 실제 서버의 구현 룰에 가깝도록 한다. Discrete Event Simulation 모델로 진행한다. 언어는 빠른 구현과 데이터 분석이 가능한 Python으로 진행한다. 데이터베이스는 작고 빠른 내장 DB를 사용하고 게임 입력과 결과 데이터에 모두 사용한다. 



## 파이썬 내장 DB

관계형 구조를 기본으로 하기위해 SQL DB를 사용한다. SQLServer를 사용할 수도 있는데 좀 더 고민하고 결정한다. 

- sqlite 
- gadfly 
- sql server
  - pymssql 

pymssql을 사용하고 sql server를 사용한다. 



## 시뮬레이션 진행 

RPG 게임은 게임 데이터와 사용자가 발생시킨 이벤트를 입력으로 한다. 코드로 실행하고 결과를 다시 저장한다.  이 과정의 무한 반복이 게임이다.  다양한 영역이 있지만 결국은 이와 같은 흐름을 갖는다.  

게임처럼 구성하기는 어렵다. 시간이 빠르게 흘러가야 한다. 하루 만에 몇 개월의 플레이가 가능해야 한다.  시뮬레이션의 핵심이며 결과 분석이 데이터 게임의 핵심이다. 

가장 어려운 점은 세부 사항에 있다. 게임 규칙은 매우 상세하며 상호 연관되어 있다. 이에 따라 예외도 많이 발생한다. 결과가 다음 시뮬레이션에 영향을 미치는 되먹임 (피드백) 구조를 갖고 있으므로 조건의 누락이나 변경은 시간이 흐르면 매우 큰 결과의 차이를 가져올 수 있다.  모든 되먹임이 chaotic 하지는 않지만 그럴 가능성이 있다. 데이터와 시뮬레이션에 의존하지만 유의해서 진행해야 한다. 그래서, 게임의 분리된 시뮬레이션이 어렵다. 



## 인터페이스 

데이터 구성과 설정 후 실행과 분석으로 진행한다.  실행 시 상태를 모니터링 할 수 있도록 한다. UI는 이쁘고 직관적이며 빨라야 한다.  게임 오브젝트들도 그리고 행동을 표현할 수 있다면 좋다. 이동 속도와 같은 데이터는 실제 이동을 통해 시뮬레이션 하지 않으면 안 되고 분포를 나타내는 방법은 그려서 보여주는 것이 가장 좋다. 



## 아키텍처 

파이썬은 단일 쓰레드로 동작한다.  고려하는 서버 아키텍처도 분산 구조이다. 따라서, zeromq와 같이 파이쎤에서 사용이 쉬운 통신 라이브러리를 사용하여 분산 처리 구조를 구현한다. 

UI도 통신을 통해 시뮬레이션 서버와 연결하고 정보를 얻도록 한다. 트래픽은 많으나 나중에 IDE로 만들 때도 도움이 많이 될 것이다. 





# 데이터 IDE 

- 빠르게 입력 가능해야 한다. 
- 입력 중 데이터 분석이 가능해야 한다. 
  - 조건에 맞는 항목들만 편집
    - 조건 필터링
  - 계산 필드 추가하기 
  - 스크립팅으로 데이터 분석하고 생성하기 
  - 빠르고 쉬운 편집
- DB를 포함한 처리 코드 생성을 한다 
- 협업 
  - 동일 파일에 동시 접근 처리 
  - 데이터 병합과 충돌 해결 
  - 서버 
    - 커널 실행 
    - 통신 처리
- 스키마 정의와 데이터 
  - 게층적 (json / bson) 
  - 관계형 (csv / 데이터베이스)
  - 커스텀 UI 생성 
  - 코드 생성



## 개요 

게임 제작과 서비스에서 데이터가 결국 모든 가치를 만들어 내는 핵심이다. 프로그램 구조와 동작도 데이터에 기반해야 한다. 규칙을 실행하는 구체적인 값들로 데이터가 사용되고, 게임의 상태를 저장하고 다음 실행을 유지하는 기반이 된다. 여러 관점과 기능에서 중요한 역할을 한다. 

데이터 제작은 클라이언트에서는 스크립트까지 하나의 통합된 환경에서 개발하는 구조를 갖추고 있고 클라이언트 엔진들에서 렌더링, 월드와 액터의 구성에 스크립트까지 포함하고 있다. 서버의 기본 문제들이 요구하는 구조가 클라이언트와 다르고 하나로 통합하여 제작 흐름을 구성하기 어려운 측면이 있어 프로그래머들이 데이터 구조를 결정하고 코드 위주로 스크립트 작성과 유사한 방식으로 지금까지 구현해 왔다. 하지만, 이런 방식은 작업 효율이 낮아지고 코드 품질을 저하시키는 핵심 원인 중 하나이다. 

더 근본적으로 보면 게임 도메인은 엔티티의 규칙에 따른 행동이 데이터와 이벤트에 기반해야 기능 단위로 분리된 구조를 만들 수 있다. 이런 구조의 핵심으로 데이터 개발이 고려되고 통합되어야 한다. 

다른 측면에서 코드 생성을 통한 개발 효율의 향상도 중요하다. 코드 생성은 앞으로 게임 개발과 프로그래밍 전체에서 중요한 영역이 될 것으로 보인다. 한번 검등된 생성코드는 생성된 코드의 무결성을 보장할 수 있기 때문에 품질을 올리는데 기여할 수 있다. 효율과 안정성을 동시에 확보할 수 있는 중요한 방법이다. 

지금까지 이런 접근이 서버 개발에 많이 쓰이지 않은 이유가 있다. 게임의 다양한 데이터와 규칙을 고정된 툴로 지원하기 어렵기 때문이다. 따라서, 툴 자체는 고정되더라도 다양한 데이터 모델과 처리를 자유롭게 구현할 수 있는 유연성을 동시에 갖춰야 한다. 이 부분이 가장 어려운 부분이다. 이를 지원하기 위해서는 개념의 확장이 중요하다. 



## 방향 



### 데이터 모델 

게임에서 사용하는 데이터 모델은 개인적인 경험에서 보면 관계형을 주로 사용해 왔다. 엑셀에서 편집하고 CSV나 바이너리 형식을 게임에서 사용하는 방법이 가장 많았다. 그 다음으로 XML이나 JSON과 같이 트리 구조의 보다 자유로운 형식 지원이 온다. 클라이언트를 보면 오브젝트 자체의 속성 편집 기능을 기반으로 한다. 클라이언트의 속성 기반 데이터 모델은 스키마가 자유롭고 바로 오브젝트에 반영되어 시뮬레이션 진행을 확인할 수 있다는 장점이 있다. 

영속성 지원을 위한 데이터베이스 모델은 관계형이 대부분이다. NoSQL의 확산으로 json이나 다른 포맷을 지원하는 게임들이 있기는 하나 전통적인 MMORPG는 여전히 트랜잭션과 안정성을 동시에 요구하기 때문에 RDBMS를 가장 많이 사용하고 있다. SSD와 DBMS 기술의 발전으로 성능도 대다수 게임을 지원하는데 어려움이 없을 정도로 성능이 좋아졌다. 여전히 잘 설계해야 하는 부분들은 당연히 있다. 

두 가지 영역을 지원하기 위해 게층형 데이터 모델과 관계형 데이터 모델 두 가지를 모두 지원하도록 한다. 두 가지 모두 처리 코드를 목적 언어의 코드로 생성할 수 있도록 한다. 시뮬레이션 중 데이터 수정은 개발 효율을 위해 중요한데 생성 코드에서 이를 반영하는 기능을 갖추도록 한다. 



### 스크립트 데이터 

행동을 조건에 따라 언어 수준으로 결정하고 지정할 수 있다면 프로그래머의 부담이 많이 줄어든다. 여건에 따라 다르지만 이런 분리는 프로그래머의 부담을 줄이는 것처럼 보이는 초기 진행의 이득 보다는 스크립트 작성자들의 수준에 따라 버그가 많아지고 여러 언어를 디버깅 해야 하는 어려움이 더 커지는 손해가 클 수도 있다. 

따라서, 계층형 데이터에 조건을 추가하고 행동을 선택할 수 있도록 하는 방법과 Haxe 언어의 접근처럼 Transpiler (다른 언어로 컴파일)를 사용하는 것도 고려할만 하다.  

### 서버 연동 

IDE는 서버의 IDE로 발전한다. 데이터 IDE이자 쉘이다. 

## 설계 

### 기능 분류

- 데이터 에디터 

  - 계층 
  - 관계 
    - 영속 
    - DB 

- 행동 에디터 

  - C++ transpiler 
  - simple c++ like language
  - 문법 체크 
  - 생성 및 실행 체크 

- 협업 

  - 채팅  
  - 병합 
  - 동시 작업 

# 행동 정의 언어 

## HLBL의 아이디어 

자료 / 행동 언어 항목에 있는 자료 참고.

HLBL (HIgh Level Behavior Language)는 전에 생각했던 간단한 스크립트 언어로 행동을 선택할 수 있도록 하고, C++로 변환하여 빠르게 실행되도록 하는 방법과 가장 비슷하다. 

if 문 등을 지원하지는 않고 키워드 기반으로 조건과 행동을 선택하는 기능만 갖는다. C++ 코드는 행동을 함수 단위로 하고 액션을 while 문으로, 조건을 if 문으로 한다. 이와 같은 코드는 게임에서 사용할 수 없으므로 Behavior Tree와 같이 현재 선택된 행위를 지속하도록 수정해야 한다. 

아이디어 자체는 괜찮다. 

키워드는 다음과 같다. 

- behavior
- startswhen 
- endswhen 
- children 
  - 자식 behavior들 
- following 
  - 연속해서 실행할 behavior들 
- cond 
- choice


## 방향 

유사한 접근을 갖도록 한다.  엔티티에 내장된 행동 제어에 사용하는 것으로 가정한다. behavior가 길어 짧은  act로 한다. 

- act:  name 
- name when:  boolean expression 
- name when: boolean expression 
- on: event 


when, on 다음에는 행위들이 오고 다음과 같다.

- call function( args )
- tran behavior 
- end 

on에 오는 event들은 다음과 같다. 

- "begin" 
- "end" 

이벤트 처리와 연결할 필요가 있는 지 확인해야 한다. 없어도 괜찮을 것 같다. 

```c++
struct act_name : public act
{
    act_name( comp_behavior& c )l;
    result on_begin() override; 
    result on_run() override; 
    void on_end() override;    
}
```
name when: 은 when 조건이 될 경우 name 함수를 호출하는 것으로 한다. 

코드 블럭이 when:, on: 다음에 올 수 있다. 한 줄 또는 여러 줄이 온다. 다른 키워드를 만나기 전까지를 실행 코드로 본다. 

스크립트 인터프리터의 구현이 필요하다. 실행을 처리할 때 필요한 기능은 다음과 같다. 

- c++에서 스크립트 실행 여부 결정 
  - c++로 생성한 behavior_name이 더 이전 버전인 지 확인
- c++의 entity 수준 함수 호출 가능하게 만듦 
  - reflection 기능을 통해 호출 가능하게 만듦
- 스크립트 파스 트리 생성 
- behavior_scripted : public behavior 
  - behavior_name 항목에 대해 실행 
  - on_begin에서 이벤트 검색 

파서를 만들기 전에 json으로 PoC를 진행하고 적절한 문법으로 파서를 만든다. 


# 분산 개발 환경

이제 서버 자체가 IDE 서비스를 제공해야 한다. 협업이 가능하고 파일 전송도 가능해야 한다. 분산 개발 환경이 된다.

- git 





# 자료 


- playmaker 
  - https://hutonggames.com/index.html
  - unity3d asset 
  - visual scripting language 
- game maker 
  - https://www.yoyogames.com/
  - cef gui 
  - 에디터 c# 으로 개발 
  - 유니티 등 기존 엔진과 유사하다
  - 빠르게 2D 게임을 만들 때 유용하다. 
- 행동 언어 
  - http://www.cs.cmu.edu/~mmv/papers/04aamas-HLBL.pdf
  - 행동 정의 언어 
  - 코드 생성 언어

