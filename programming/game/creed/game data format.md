# Game data format

계층적 csv 면 대부분 된다. 다른 시도가 잘 안 되면 이를 사용한다. 



## son 

structured object notation. c++ / c / c#의 정형화된 struct와 vector (array) 기반의 데이터 포맷 정의를 구현한다. 

 ### 기본 아이디어

- json 형식에서 매번 서술해야 하는 점 제거 
  - 스키마와 데이터를 분리한 구조 
  - 레코드와 배열 타잎
  - json 파서들에서 수정해서 사용 가능할 듯  

```json
[
{
    value only, 
    3, 
    3.5, 
    [ 3, 1, 3 ], 
    [ { 1.0, fire }, { 2.0, cancel} ]
}, 
...
]
```

json과 유사하지만 map을 제거. 레코드와 배열만 있다. 레코드와 배열은 타잎이고 각 타잎은 다른 타잎을 값으로 가질 수 있다. 배열은 같은 타잎만 갖는다. 

스키마도 같은 형식으로 지정한다. 문자열도 쉼표 이외에는 모드 그냥 적을 수 있다. 

enum의 처리가 필요하다. 구조의 하나로 스키마로 정의한다. 스키마 체계도 중요하다. 

### 파싱 

json 파서를 수정하거나 spirit 기반으로 작성한다. 코드 생성기를 갖추고 로딩을 각 언어의 구조로 읽을 수 있게 한다. 바이너리로 변환 가능하게 한다. 바이너리 변환과 로딩은 serialize / deserialize 과정이다. 

### 편집

이 부분이 가장 어렵다. 트리 형태가 적합하다. 편집 중심으로 사용성을 정리해야 한다. 최소한은 카드 형태로 편집하는 것이다. 다른 son 파일의 필드를 참조로 가져올 수 있게 한다. 엑셀처럼 연관된 파일로 만든다. 

엑셀에서 편집 가능하게 만드는 것이 가장 좋다. 그렇게 하려면 행렬로 만들어야 한다. 행렬이 되려면 배열과 레코드를 컬럼화를 시켜야 한다. 최대 길이를 주고 빈 레코드를 null로 채울 수 있게 하면 된다. 

### 스키마 파일 

skill.schema 파일에 구조를 정의한다. 같은 형식으로 정의하면 좋겠다. 

{

   skill_info, 

   [ 

​     { name, string }, 

​     {last name, string}, 

​     {lst, int[]} , 

​     {act, skill[] }  

   ]

}

위의 메타 정의는 레코드로 { record_type, [ fields, field[] ] } } 가 되고 field는 레코드로 이름과 타잎을 갖는다. 같은 형식으로 자기를 정의할 수 있어야 한다. 

### 중간 평가 

일이 너무 많아진다. 파서, 편집기 모두 부담 스럽다. hcsv가 좋을 듯 하다. 



###

## 자료

https://github.com/npruehs/tome-editor

- 게임 데이터 에디터로 검색 
- Qt에서 작성한 게임 데이터 편집기 
- 편집 후 export 방식 
- validation 기능을 내장 

https://www.celtx.com/gem/index.html

- 게임 디자인 솔루션 

















