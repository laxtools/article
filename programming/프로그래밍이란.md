# 프로그래밍이란?

프로그래밍이란 무엇인가?

우선, 프로그래밍으로 무엇을 할 수 있는 지를 보면 알 수 있다.

프로그래밍은 컴퓨터에 일을 시키는 방법이다.
컴퓨터에 일을 시키려면 컴퓨터란 실행 기계에 명령을 전달해야 한다.

컴퓨터는 저장소와 CPU를 갖고 있고 네트워크를 통해 통신할 수 있으며
GPU를 통해 화면에 뭔가를 표시할 수 있다.

세부적으로는 절차적이거나 함수형으로 서술된 수학적인 알고리즘을
만들고 이들을 묶어서 단위 구조를 생성하고 단위 구조를 엮어서
시스템을 만든다.

메모리와 디스크에 저장된 상태와 데이터를 사용하여 계산하고
화면에 표시하고 입력을 받고 네트워크로 공유한다.

## 알고리즘

가장 밑단에 알고리즘이 있다. 빠르게 찾고, 저장하고, 정렬하고, 계산한다.

렌더링은 빛과 면 사이의 계산 알고리즘들로 구성되고
충돌은 입체와 선/면/입체들의 관계로 구성된다.
길찾기는 그래프의 노드들 간의 관계에 기반한 계산이다.

트랜잭션은 데이터 조회와 변경에 대한 접근 제어 알고리즘이다.

주로 데이터, 관계, 계산에 대한 처리 방식이 알고리즘을 구성하다.
알고리즘의 구성은 데이터 구조와 관계에 기초한다.

렌더링, 암호화나 수치 해석과 같이 수학적인 바탕이 필요한 경우가 많다.
수학은 렌더링과 같이 해석적이거나 트랜잭션이나 암호화와 같이 대수적인 경우로
나눠서 생각해 볼 수 있는데 수학이 해석적으로 시작하고 대수적으로
발전하는 형식이니 마찬가지로 발전을 만들어 볼 수 있다.

알고리즘은 증명되어야 한다. 기본적인 특성이다. 두 가지를 증명해야 하는데
하나는 정확성이고 다른 하나는 성능 특성이다.

## Abstract Data Type / Concept / Interface

알고리즘이 상태 변화에 기초할 경우가 많다. 순수 함수형 언어라면
다른 접근을 취하겠으나 "순수"하게 데이터를 변경하지 않더라도
"변경된" 데이터의 복제본은 상태 변경을 포함하는 것으로 해석할 수 있다.

따라서, 복잡한 상태 변화를 구조화하는 전단계로 꼭 필요하기도 하고
그 자체로 순수한 대수적인 대상으로 만들기 위해서 추상적인
구조로 만들 필요가 있다.

이렇게 만들어진 대상의 예로 vector, map 등의 컨테이너나 socket을 생각할 수 있다.
이들은 동작에 대한 인터페이스이자 추상적인 객체로 생각할 수 있다.

ADT는 C++에서 주로 많이 사용된 개념의 구현으로 생각할 수도 있다.
세부 개념들을 포함한 ADT로 생각할 수 있다. 주로 컨테이너에서 사용한 것들이다.

인터페이스도 개념의 인터페이스로 분리해서 생각해 볼 수 있다.
구조화를 위한 필요에 따라 인터페이스를 만들게 되면 논리적인 비약이나
확대가 생길 가능성이 높다. 따라서, 딱 맞는 개념들의 조합으로
인터페이스와 ADT를 먼저 따로 생각해 보면 좋다.

ADT는 함수와 데이터를 포함한다. 동작만 하는 것이 아닌 데이터도
ADT화 해야 한다.

## 구조

게임을 구현하다 보면 여기서부터 시작하는 경우가 많다. 어떤 때는
더 큰 시스템부터 시작할 경우도 많다. 잘못된 접근이라기 보다는
이 쪽 방향에만 맞춰서 진행하면 근간이 되는 알고리즘이나 개념이
약해서 매번 새로 구현하고 유지보수가 어려운 구조가 될 가능성이 높다.

따라서, 오가면서 살피는 게 필요하다. 밑에서 위로, 위에서 아래로
오가면서 단단하게 만들어야 한다.

Bottom up과 Top down 접근이 모두 필요한 이유는 구조를 만들 때와
알고리즘을 만들 때 우리의 사고 체계가 다르게 동작하는 것으로 보이기 때문이다.
또, 사람마다 특정 영역의 알고리즘에 더 잘 맞는 경우가 있는데
이를 분리해서 보지 않으면 "동작"에만 관심을 둘 경우가 많이 생긴다.

구조는 사용 관계로 만들어진다. 프로그램에서 사용은
ADT(인터페이스, 개념)의 생성과 호출로 이루어진다.

ADT의 호출 의존이 복잡하면 버그가 만들어질 가능성이 많다.

이를 단순화하기 위한 기법들 중 이벤트, 통지 (콜백/이벤트), 데이터 화
등이 있다. 사용하기 쉽고 버그를 만들기 어려운 구조화가 핵심 기술이다.

### 시스템

구조화된 기능들이 특정 영역의 요구 사항을 모두 만족시킬 때
시스템화 되었다고 얘기할 수 있다.

예를 들어, 아이템의 생성, 소멸, 이동을 모두 처리하고 트래킹 가능할 경우
시스템화 되었다고 할 수 있다.

명시적으로 System이 붙은 경우도 있을 수 있고 몇 가지 구조를 묶어서
시스템이라고 할 수도 있으나 개념상 "시스템"으로 정의하고
사용성이 완결된 "구조"를 찾는 것이 중요하다.

### 관계의 형성

동일한 개념(인터페이스)을 구현한 상속 관계, 생성하고 소유하는 관계,
전달 받거나 참조하여 사용하는 관계로 나눠서 볼 수 있다.

상속 관계는 ADT 상속보다는 개념의 상속으로 보아야 하고
java나 C# 처럼 interface의 상속을 주로 사용하는 것이 낫다.

예를 들어, Entity로 상속 받기 보다는 스폰 가능하고 업데이트를 받는
개념들을 구현한 것으로 보는 게 나을 수 있다.

위의 기본적인 OOP의 세 가지 관계 외에 실제 구현 관점에서
이벤트를 통한 인터페이스의 구성이나 데이터 기반의 실행 인터페이스도 중요하다.

컴퓨터 자체처럼 특정 명령어를 실행하는 기계로 구성하면
함수 호출 관계보다 유연하게 구현되는 경우가 많다.

이는 스킬이나 AI 구성에서 매우 중요한 역할을 한다. 

## 테스트

알고리즘과 ADT에 대한 테스트를 단위 테스트로 본다.

구조와 시스템에 대한 테스트를 기능 테스트로 본다.
